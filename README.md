# 主要工作经验
#### 基于Unity的MMORPG项目
- [**行为树**](#行为树) 在服务器端使用c++编写的基于事件驱动的行为树。
- 行为树编辑器 依赖Unity的行为树编辑器，支持行为树导出及实时调试，支持通用子树。
- [**技能系统**](#技能系统) 客户端技能系统的实现。并通过导出root motion使用逻辑层播放增强技能表现，使用CinemachineTargetGroup增强打击感。实现了技能预表现与回滚。
- 副本 在服务器端实现的副本系统，配合服务器的事件、条件、旗标系统，通过策划配置实现不同副本的副本玩法。
- [Shader](#Shader) 角色，怪物，场景，UI特效，UI镜面，场景水面。
- [**网络底层**](#网络底层) 替换原有通信协议变为protobuf，为了减少GC提高解析效率，修改为在c代码侧收发、解析probubuf，并进行解压和解密。
- [UI通用组件] 支持任意大小，任意类型子节点的无限循环列表。方便使用的属性列表。变色文字，优化TextMeshPro图文混排支持使用图集。
- [*性能优化*] 显示效果分级，Shader内存占用优化，配置档内存占用优化，特效渲染层级优化工具。
- [资源发布与检查工具] 对场景、场景对象、特效等的资源优化与检查.
- 寻路与高度图 记录场景高度图用来查找地图上任意一点地面高度，实现A*寻路。
- [UI框架与配套工具](#UI框架与配套工具) 设计了思路，指导同事完成了一个便于快速开发的UI发布工具，生成通用代码，支持代码热加载等。
- [帮助他人完成] 挂机系统，红点系统，lua行为树，资源混淆方案等。
#### 2D横版ARPG游戏
- [帧同步] 两个玩家控制六个角色进行实时帧同步战斗打副本。配套制作了同步验证方案。
- [技能系统] 使用json格式配置，技能，Buff，事件三者互相触发、作用实现复杂的实时技能系统。
- [UI框架] UI层级管理，生命周期管理。
#### 基于Unity和地理位置的大富翁游戏
- [无缝地图] 地图数据预处理，流式地图生成。
#### 业余项目
- [基于GO的分布式服务器] 出于对之前项目的问题的思考，制作的一个基于GO的分布式服务器。[项目连接](https://github.com/iNeverSleeeeep/INServer)
- [配置档工具] 基于对项目现有问题的思考，制作了一个功能、性能强大并且有较大扩展潜力的配置档导出工具。[项目链接](https://github.com/iNeverSleeeeep/Game-Config-Tool)
- [Unity对象池] 代码简单，扩展性强的Unity对象池。[项目地址](https://github.com/iNeverSleeeeep/GameObjectPool)
- [热更新框架] 支持多线程下载、断点续传、稳定可靠的热更新框架。代码简单方便用来学习。[项目链接](https://github.com/iNeverSleeeeep/UpdateResourceTool)

## 详细说明
#### 行为树 
普通的行为树在树层次较深的时候，每次重新决策的性能压力较大，且重新决策的频率较为频繁，为了解决这个问题，我实现了一套基于事件驱动的行为树。
这种行为树的特点是，重新决策的时机依赖于状态改变，当发生状态改变时，找到**监听这个改变的节点**和**当前正在执行的Action节点**的**公共父节点**，如果**改变节点**的优先级高于**当前节点**，从这个父节点开始重新角色，通过这种方式，既减少了决策深度，又减少了决策频率。状态改变事件及各个节点共享数据通过**黑板**对象（使用map存储数据，提供一组监听map和改变map的接口）。
行为树包含以下四种类型节点
- Action节点 执行逻辑，执行完毕后重新触发决策。
- Service节点 定时刷新状态，修改**黑板**状态。只有当前激活分支上的Service节点可以定时执行。
- Condition节点 判断分支是否可以执行，并且监听**黑板**状态改变，当改变发生并且会改变自身的条件通过性的时候，会触发重新决策。
- Select节点 分支选择节点，提供顺序执行子节点功能和选择执行子节点功能。
[回到顶部](#readme)
#### 技能系统
- 设计时合理使用了较少的代码和状态代码来减少了产生BUG的可能。
- 使用状态机切换技能动作，技能动作可取消后摇，支持连击。
- 因为来用了逻辑执行美术制作的位移动作，技能位移表现很强，技能实时性和交互性也很强。
- 制作了两种震屏方式，策划配置与自动摄像机跟随。摄像机使用Cinemachine实现，Lookat使用的是CinemachineTargetGroup，这个组件的功能是可以在几个节点之间根据权重做差值，我将CinemachineTargetGroup增加了两个目标，脚下和主武器位置，这样如果玩家在执行一个跳起动作时，摄像机会有一定的跟随和振动，效果较好。
- 技能都是客户端先释放，并通知服务器端，如果这次技能释放失败，制作了动作/声音/特效/震屏的重置。
[回到顶部](#readme)
#### Shader
- 场景对象使用了Blinn-Phone光照模型，每个角色主体使用固有色、法线和通道三张贴图。
- 高配下使用了额外的摄像机增加了水面的反射效果。UI中也增加了额外摄像机实现角色脚下的镜面效果。
- 场景的Shader替换为一个最简单的只采样地表贴图和光照贴图的Shader。
#### 网络底层
原有网络模块是做在c#侧，并且消息头使用自定义协议，消息体使用protobuf但是是在lua代码中进行解析。
存在以下三个问题：
1. c#侧向lua侧传递字符数组时，存在较大的GC。
2. 消息头使用自定义协议，与消息体的解析不统一，需要两套代码。
3. 在lua代码中解析protobuf消息性能低下。
为了解决以上问题，我的修改方式是，网络部分使用c代码实现，循环使用一个预申请的*char[]*，保证0GC。协议头也替换为protobuf协议（包含客户端和服务器的修改），然后使用一个c库来作为protobuf的解析，解析效率提高为原本的4倍。
#### UI通用组件
- 无限循环列表 任意类型，任意大小子节点都可以放入无限循环列表，无需预先定义节点大小，无需为子节点添加多余组件，非常易于使用。 根据当前Content和Viewport的大小，调整子节点的位置和数量，达到无限循环列表的功能。因为UGUI没有正式提供根据子节点大小设置当前节点大小的组件（ContentSizeFilter不是为了实现这个功能，使用这个常常会有显示BUG），实现了根据多子节点大小设置父节点大小的通用组件，这个是实现无限循环列表的前提。
- 属性列表 普通的属性列表可能包含较多的子节点，需要预先制作每种子节点的预制，为了提高研发效率，制作了这个属性列表。使用配置档定义属性格式，支持图文混排，不同文字颜色大小，不同列数，不同列大小，任意对其方式。
